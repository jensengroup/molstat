\documentclass{article}

\input{../handout_preamble}


% ***************************************************
% HEADER INFORMATION

\title{Exercise 4}
\author{Molecular Statistics, Week 4}
\date{}

% ***************************************************

\begin{document}


% ***************************************************
% BEGIN DOCUMENT
% ***************************************************

\maketitle

\section{Introduction}

The goals of this exercise:
\begin{enumerate}
    \item Write a molecular-dynamics program in two dimension using the supplied module.

    \item Implement a 3D Velo-Verlet solver, using Numpy Arrays.

    \item Extend the program with functions to calculate the following properties:

    \begin{enumerate}
        \item Kinetic energy
        \item Total energy
        \item Temperature
        \item Pressure
    \end{enumerate}

    \item Visualize your results in a 3D video.

\end{enumerate}

You should read the Numpy handout available on the course website.

\subsection{Lennard-Jones potential and periodic boundary conditions}

The potential we are using this week is almost the same Lennard-Jones potential as we saw last week.
You may recall from your simulation last week, that the calculation of the particle pair-interactions took a long time to compute, even with only 10-20 particles.
To speed up the calculation time we can make the approximation that only particles closer than a certain minimum distance $r_{\mathrm{cut}}$ are interacting.
This is a justified approximation, since particles that are far apart have weak interactions.
Here we set $r_{\mathrm{cut}} = 2.5$.
Using this approximation, we can define the potential energy between two interacting particles $i$ and $j$ by:
\begin{eqnarray}
    U_{ij} &= 
    \begin{cases}
        \ \ 4 \left[ \left(\frac{1}{r_{ij}} \right)^{12} - \left(\frac{1}{r_{ij}} \right)^6 \right] -E_{\mathrm{cut}} & \mathrm{if}\ \ r_{ij} < r_{\mathrm{cut}}\\
        \ \ 0 & \mathrm{if}\ \ r_{ij} \ge  r_{\mathrm{cut}}
    \end{cases}
\end{eqnarray}

The derivatives of the potential energy are used to calculate the forces
between particles:
\begin{equation}
    \mathbf{F} = -\nabla U =
    -\left(
        \frac{\partial U}{\partial x_1},\
        \frac{\partial U}{\partial y_1},\
        \frac{\partial U}{\partial z_1},\
        \frac{\partial U}{\partial x_2},\
        \frac{\partial U}{\partial y_2},\
        \frac{\partial U}{\partial z_2},\
        \ldots\ ,
        \frac{\partial U}{\partial x_n},\
        \frac{\partial U}{\partial y_n},\
        \frac{\partial U}{\partial z_n}
    \right)
\end{equation}

The $x$-components of the force between two interacting particles $i$ and $j$
are:
\begin{eqnarray}
    -\frac{\partial}{\partial x_i} U_{ij}&=& 
    \begin{cases}
        \ \ -48\ \frac{x_j - x_i}{r^2_{ij}}
        \left[ \left(\frac{1}{r_{ij}} \right)^{12} - 0.5 \left(\frac{1}{r_{ij}} \right)^6 \right]
        & \mathrm{if}\ \ r_{ij} < r_{\mathrm{cut}} \\
        \ \ 0 & \mathrm{if}\ \ r_{ij} \ge  r_{\mathrm{cut}}
    \end{cases}\label{eq:force_i}\\
    -\frac{\partial}{\partial x_j} U_{ij}&=&
    \begin{cases}
        \ \ \ \ 48\ \frac{x_j - x_i}{r^2_{ij}}
        \left[ \left(\frac{1}{r_{ij}} \right)^{12} - 0.5 \left(\frac{1}{r_{ij}} \right)^6 \right]
        & \mathrm{if}\ \ r_{ij} < r_{\mathrm{cut}} \\
        \ \ 0 & \mathrm{if}\ \ r_{ij} \ge  r_{\mathrm{cut}}
    \end{cases}\label{eq:force_j}
\end{eqnarray}

The $y$- and $z$-components are defined in the same way.

\subsection{Velo-Verlet integration and periodic boundary conditions}

Last week your setup confined the particles in the simulation inside a box with hard walls.
Today's exercise uses periodic boundary conditions in the minimum-image convention.
%
You don't have to implement this code, since it's already implemented in the FORTRAN library you will be using.
The Velo-Verlet integrator you have to implement is thus very simple (and identical to last week).
The Velo-Verlet equations for integrating the positions and velocities are (in the $x$-direction for one particle):

\begin{eqnarray}
    R_x(t + dt) &=& R_x(t) + dt\ V_x(t) + 0.5\ dt^2\ A_x(t) \label{eq:position_x}\\
    V_x(t + dt) &=& V_x(t) + 0.5\ dt \left[A_x(t) + A_x(t+dt)\right] \label{eq:speed_x}
\end{eqnarray}

In the program you will be implementing today, we will again set the mass of the particles to 1, such that the value of the acceleration is equal to the value of the force.\\

Let's recap: The Velo-Verlet algorithm uses the forces, velocities and positions from the current position to calculate the forces, velocities and positions after the next time-step.
In short it is a three-step procedure:

\begin{enumerate}
    \item Calculate new positions using Eq. \ref{eq:position_x}
    \item Calculate new forces using Eq. \ref{eq:force_i}-\ref{eq:force_j}
    \item Calculate new velocities using Eq. \ref{eq:speed_x}
\end{enumerate}

The resulting forces, velocities and particle positions are then saved as input for the next Velo-Verlet integration step.

\subsection{Kinetic energy}

The total kinetic energy of the system can be calculated as:

\begin{equation}
    E_{\mathrm{kin}} = \sum_i \frac{1}{2} m_i |\vec{v_i}|^2
\end{equation}

In our simulation $m_i$ is set to 1, so the above reduces to:

\begin{equation}
    E_{\mathrm{kin}} = \frac{1}{2} \sum_i |\vec{v_i}| \cdot |\vec{v_i}|
\end{equation}

% \textbf{Hint:} If you do this in Numpy, the above summation is simply carried
% out as:
% 
% \begin{lstlisting}[language=python]
% e_kin = np.sum(V * V) * 0.5
% \end{lstlisting}
% 
% Why is this true? What does V * V do and what does np.sum() do?


\subsection{Conservation of energy}

If your simulation is successful the total energy will be conserved. That is:

\begin{equation}
    E_{\mathrm{total}} = E_{\mathrm{pot}} + E_{\mathrm{kin}} \approx \mathrm{constant}
\end{equation}

Conservation of energy can sometimes fail during a MD simulation.
Often this is due to the timestep $dt$ being too large, which causes the numerical Velo-Verlet integration to fail.


\subsection{Instantaneous temperature}

The first thermodynamic property we will derive from our simulation is the instantaneous temperature,
that is the temperature as a function of time, $T(t)$.
You will sometimes see the temperature defined in terms of the average kinetic energy per degree of freedom in a system:

\begin{eqnarray}
    \langle E_{\alpha} \rangle = \frac{1}{2} k_\mathrm{B} \ T
\end{eqnarray}

where $\alpha$ denotes the degrees of freedom in the system.
The above states that each degree of freedom gives a contribution to the temperature which is proportional to the kinetic energy of the individual particles.
Instead of this formulation it is more practical for our purpose to write the temperature in its instantaneous form:

\begin{eqnarray}
    T(t) &=& 2 \frac{E_{kin}(t)}{k_\mathrm{B} \ N_\alpha }\\
         &=& \sum_i \frac{m_i|\vec{v_i}| \cdot |\vec{v_i}|}{k_\mathrm{B} \ N_\alpha}
\end{eqnarray}

where $N_\alpha$ is the number of degrees of freedoms, i.e. $N_\alpha = N_{\mathrm{dimensions}} \cdot N_{\mathrm{particles}}$. Note; that we use fundamental units and simple masses, so $k_\mathrm{B} = 1$ and $m_i = 1$.\\

If the simulation is run with constant temperature $T$, the velocities needs to be scaled with a factor $\alpha$ which is calculated from the desired temperature $T$ and the current temperature $T_\mathrm{kin}$.
\begin{eqnarray}
    \alpha = \sqrt{T/T_\mathrm{kin}}
    \label{eq:temp_factor}
\end{eqnarray}


% \textbf{Hint:} If you do this in Numpy, this can be written easily as:
% \begin{lstlisting}[language=python]
% temperature = 2.0 * e_kin / np.size(V)
% # or
% temperature = np.mean(V * V)
% \end{lstlisting}
% 
% Why this is true? What does np.size() calculate? What does np.mean() calculate?
% Why do both implementations yield the same result?


% \subsection{Instantaneous Pressure}
%
% The instantaneous pressure in a Van der Waal gas simulation can be calculated as:
%
% \begin{eqnarray}
%     P(t) & = & \rho \ T(t) + \frac{1}{3V_\mathrm{box}}  \sum_{i>j} \vec{F_{ij}} \cdot \vec{r_{ij}}\\
%          & = & \rho \ T(t) + \frac{1}{3V_\mathrm{box}} W_{vir} \label{eq:intmp}
% \end{eqnarray}
%
% where $V_\mathrm{box}$ is the volume of the box,
% $\rho$ is the particle-density of the box, and
% $W_{vir} = \sum_{i>j} \vec{F_{ij}} \cdot \vec{r_{ij}}$ is the Clausius virial function (or \textit{virial} for short) of the system.\\
%
% Since we were not using a standard Lennard-Jones potential (we use a small cut-off distance),
% we have to add a small correction (the \textit{tail correction}) to Eq. \ref{eq:intmp} in order to account for the interaction we are neglecting:
%
% \begin{eqnarray}
%     \Delta P_\mathrm{tail} & = & \frac{16}{3}\pi \rho \left[ \frac{2}{3}\left( \frac{\sigma}{r_{\mathrm{cut}}} \right)^9 - \left(\frac{\sigma}{r_{\mathrm{cut}}} \right)^3 \right]
% \end{eqnarray}
%
% Here we simply set $\sigma = 1$. Remember $r_{\mathrm{cut}} = 2.5$.

\newpage


\section{Numpy Exercises}

% TODO methods
% np.save
% np.load
% random, random.seed, random.randint

% TODO Vector methods
% restrictions (no append method)
% min, max (maybe argmin and argmax?)
% sum, prod
% mean
% shape
% +=, -=, *=, /=



When working with Python "in the real world" you will most often use Numerical Python (NumPy) and vectorization.
This is because it is faster and easier to work with.
Numpy is a fast library of functions and data types.
It is mostly used for substituting the normal Python List for a new data type called \code{ndarray}.\\

As an example, generating an empty list of zeros with the two different methods:

\begin{lstlisting}
import numpy as np
list = [0.0 for i in range(5)] # Normal list
array = np.zeros(5)            # Numpy array (ndarray)
\end{lstlisting}

A huge advantage of using Numpy arrays is vectorization commands.
In general you can change a float or integer variable by using commands like
"\code{+=}",
"\code{-=}",
"\code{*=}",
"\code{/=}". So the code

\begin{lstlisting}
a = 45
a = a + 5
\end{lstlisting}

is equivalent too

\begin{lstlisting}
a = 45
a += 5
\end{lstlisting}

With Numpy arrays, you can perform mathematical operations on every element at once,
just like before.
\begin{lstlisting}
V = np.zeros(5)
V += 5
\end{lstlisting}

\begin{enumerate}[resume]
    \item Execute and evaluate the above command.
        What is the result of V?
    \item This does not work with normal Python Lists. Why? 
\end{enumerate}

When you create a Numpy array, you always specify a size.
This represents how much computer memory is allocated by Numpy.
For this reason it is not possible to use the \code{append} method, as with the Python list datatype.\\

You can create any kind of dimensional array with Numpy, i.e. here is a 5x3 array of zeros;

\begin{lstlisting}
V = np.zeros((3,5))
\end{lstlisting}

\begin{enumerate}[resume]
    \item What is the result of V?
\end{enumerate}

If you are not sure how big your array is going to be, you can create a list, append elements,
and then after all elements are appended, convert it to a Numpy array as following.

\begin{lstlisting}
L = []
for i in range(10):
    L.append(i)
L = np.array(L)
\end{lstlisting}

A very useful command to use is \code{np.arange()}, which is similar to the \code{range()} command.

\begin{enumerate}[resume]
   \item Execute the code

\begin{lstlisting}
num_vector = np.arange(0, 5)
print num_vector
num_vector = np.arange(0, 5, 0.1)
print num_vector
\end{lstlisting}

   and explain what the method \code{np.arange()} does.

   \item What does \code{np.sum()} do? Using \code{num\_vector} from before, what is the result of the following code?

\begin{lstlisting}
np.sum(num_vector)
\end{lstlisting}


   \item What does \code{np.mean()} do and what is the result of the follow code?

\begin{lstlisting}
np.mean(num_vector)
\end{lstlisting}

   \item What does \code{np.random.uniform(0.0, 1.0)} do?

   \item (Optional) How to get a random float from a normal distribution, using Numpy? \newline
       {\em Hint:} Use Google.

\end{enumerate}


\newpage


\section{Molecular Dynamics using modules and anaconda}

Before you begin the exercise make sure to  download \code{md\_header.py} and \code{md\_video.py} from the course website.
You will also need the Anaconda package, by writing the following into a terminal
\begin{lstlisting}
wget -q -O - http://dgu.ki.ku.dk/molbox/setup.sh | bash
\end{lstlisting}

You will want to use the \code{md\_header.py} for the initialization and calculation of the LJ forces, which is done by importing it:

\begin{lstlisting}
import numpy as np
import md_video as video
import md_header as md
\end{lstlisting}

The \code{initialize\_particles} function from the header takes as arguments
the number of atoms, temperature, density (rho) and epsilon matrix (eps).
Epsilon is now a matrix (of ones) because we will use differing epsilon values later.
The function returns the positions, velocities, forces and box width, based on the temperature and density.

\begin{lstlisting}
eps = np.ones((n_atoms, n_atoms)) # eps is still 1
R, V, F, box_width = md.initialize_particles(n_atoms, temp, rho, eps)
\end{lstlisting}

\code{R} is an $N\times2$ array, which holds the $x$ and $y$ coordinates for all $N$ particles.
Likewise \code{V} and \code{F} holds the initial velocities and forces respectively.
\code{box\_width} is the width of the scaled box, which today you cannot specify yourself,
since it is based on the density of the particles.\\

%\begin{enumerate} % Virker lidt ligegyldigt når du lige har skrevet det.
%    \item Understand the variables R, V and F. What are the dimensions and data types of the variables?
%\end{enumerate}

The second function that you will use from the md module is \code{lennard\_jones} which takes as arguments positions, box width and eps (where eps is the matrix defined earlier).
It returns the potential energy and the force.

\begin{lstlisting}
energy_potential, F = md.lennard_jones(R, box_width, eps)
\end{lstlisting}

\begin{enumerate}[resume]
    \item Understand the return values from the two functions.
        What are the dimensions and data types of the variables?

 
    \item Create a function called "simulation" that takes the following parameters as input:
        number of atoms,
        number of steps,
        particle density (rho),
        temperature and
        time step (dt).


    \item In the simulation function implement the Velo-Verlet solver from last week,
        but using the cool new Numpy tricks.
        You don't need to check if the particles exit the box since the \code{lennard\_jones} function uses periodic boundary conditions.
        Note, except for the loop over steps, there should not be any loops in the simulation function.
       {\em Hint:} See page 2 for the Velo-Verlet algorithm if you forgot it.


    \item Create a new python file and import the module you just created. Call the simulation function with the following constants.
\begin{lstlisting}
temperature = 2.0
rho = 0.2
dt = 0.0005
n_steps = 500000
\end{lstlisting}


    \item Create a movie using the video module.

    \item Save the kinetic energy, potential energy and total energy.
        Plot the energies vs steps.

    \item Find out when equilibrium, and make sure the system is in equilibrium before plotting data.

    \item Calculate and save the temperature.
        Plot the temperature vs steps.

    \item Why is the temperature not constant?

    \item Create a function \code{scale\_temp} with the parameters velocities and wanted temperature.
        Scale the temperature and return the velocities.
        
    \item What happens to the total energy if you scale the velocities?

    \item Make a video of a gas, liquid and solid simulation, using different constant temperatures.

\end{enumerate}


Next, let's look at a what will happen if we add different particles to the simulation.
The way we do this is by changing the epsilon values, so the interaction/potential is different.\\

In out matrices of particles we now choose particle 0 and 1 is of different type.
Because these new particles interact with each other and others we now have 3 different epsilon values.
Instead of setting the epsilon values to 1, we set it for each individual interaction type.

\begin{itemize}
    \item type a - type a (eps = 0.8)
    \item type a - type b (eps = 0.1)
    \item type b - type b (eps = 0.1)
\end{itemize}

Which is done by the following code

% change values
\begin{lstlisting}
eps = np.ones((n_atoms, n_atoms))
for i in range(n_atoms):
    for j in range(n_atoms):
        if i > j:
            eps[i,j] = 0.1

            if j <= 1:
                eps[i,j] = 0.1

            if i <= 1 and j <= 1:
                eps[i,j] = 0.8
\end{lstlisting}

\begin{enumerate}[resume]
    \item Set number of particles to 4 and print out the matrix.
        Is the eps values in line with interaction types?
\end{enumerate}

To add a different color to the first two particles, use the video module lige this
% add colors
\begin{lstlisting}
# set particle 1 and 2 to other color
colors = ['#4daf4a' for _ in range(n_atoms)]
colors[0] = "#377eb8"
colors[1] = "#377eb8"
video.add_color(colors)
\end{lstlisting}

% simulate

\begin{enumerate}[resume]
    \item Create a video of the two particle types.
\end{enumerate}

When calculating the distance between the two particles, you have to keep in mind that we are now operating under periodic boundary conditions, and must correct acordingly.
The distance between particle 0 and 1, in a perodic box, can be calculated as

% calculate distance
\begin{lstlisting}
# calculate the distance between 0 and 1
X  = R[0, 0] - R[0, 1]
Y  = R[1, 0] - R[1, 1]
# Periodic boundary condition
X  -= box_width * np.rint(X/box_width)
Y  -= box_width * np.rint(Y/box_width)
# calculate distance
d = np.sqrt(X**2 + Y**2)
\end{lstlisting}

\begin{enumerate}[resume]
    \item Calculate the distance between particle 0 and 1 and plot with time.

    \item Calculate the binding constant $k = t_\mathrm{together} / t_\mathrm{apart}$,
        if we set the $r_\mathrm{bound} = 1.52$.

    \item A what temperature will the particles rather be apart than together?

\end{enumerate}



% ***************************************************
% END DOCUMENT
% ***************************************************

\end{document}
